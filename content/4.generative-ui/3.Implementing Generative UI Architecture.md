---
title: Implementing Generative UI Architecture
description: Step-by-step implementation guide for the Generative UI system
navigation:
  icon: i-lucide-code
---

# Implementing Generative UI Architecture

## Overview

This document provides a comprehensive, step-by-step guide to implementing the Generative UI architecture. It covers setup, implementation details, and best practices for all three archetypes: Static (Registry), Declarative (Schema), and Open-Ended (Sandbox).

## Prerequisites

### Required Technologies
- Node.js 18+ and pnpm/npm
- Next.js 14+ (App Router)
- React 18+
- TypeScript 5+

### Required Packages

```json
{
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "@copilotkit/react-core": "latest",
    "@copilotkit/runtime": "latest",
    "@mui/material": "^5.14.0",
    "@mui/icons-material": "^5.14.0",
    "@emotion/react": "^11.11.0",
    "@emotion/styled": "^11.11.0",
    "zod": "^3.22.0",
    "ajv": "^8.12.0"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "@types/react": "^18.0.0",
    "@types/node": "^20.0.0"
  }
}
```

## Project Structure

```
├── app/
│   ├── api/
│   │   └── copilotkit/
│   │       └── route.ts          # CopilotKit runtime endpoint
│   ├── genui/
│   │   └── page.tsx              # GenUI playground
│   └── layout.tsx                # Root layout with providers
├── components/
│   ├── genui/
│   │   ├── ComponentRegistry.tsx # Static registry implementation
│   │   ├── SchemaRenderer.tsx    # Declarative schema renderer
│   │   ├── SandboxRunner.tsx     # Open-ended sandbox
│   │   └── GenUIBuilder.tsx      # Unified builder interface
│   └── ui/                       # MUI component wrappers
├── lib/
│   ├── registry/
│   │   ├── index.ts              # Component registry
│   │   ├── components/           # Registered components
│   │   └── schemas/              # Component schemas
│   ├── schema/
│   │   ├── validator.ts          # Schema validation
│   │   ├── transformer.ts        # Schema to React transform
│   │   └── types.ts              # Schema type definitions
│   ├── sandbox/
│   │   ├── manager.ts            # Sandbox execution manager
│   │   ├── security.ts           # Security policies
│   │   └── worker.ts             # Web worker for isolation
│   └── copilot/
│       ├── actions.ts            # Copilot action definitions
│       └── context.ts            # Copilot context providers
└── public/
    └── sandbox-worker.js         # Sandbox worker script
```

## Implementation Steps

### Step 1: Project Setup

Initialize Next.js project with TypeScript:

```bash
npx create-next-app@latest genui-project --typescript --app --tailwind
cd genui-project
```

Install required dependencies:

```bash
pnpm add @copilotkit/react-core @copilotkit/runtime @mui/material @mui/icons-material @emotion/react @emotion/styled zod ajv openai
```

### Step 2: Configure Root Layout

Set up providers in `app/layout.tsx`:

```tsx
import { CopilotKit } from "@copilotkit/react-core";
import { ThemeProvider, createTheme } from "@mui/material/styles";
import CssBaseline from "@mui/material/CssBaseline";

const theme = createTheme({
  palette: {
    mode: 'light',
    primary: { main: '#1976d2' },
    secondary: { main: '#dc004e' },
  },
});

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <CopilotKit runtimeUrl="/api/copilotkit">
          <ThemeProvider theme={theme}>
            <CssBaseline />
            {children}
          </ThemeProvider>
        </CopilotKit>
      </body>
    </html>
  );
}
```

### Step 3: Implement CopilotKit Runtime

Create `app/api/copilotkit/route.ts`:

```typescript
import { CopilotRuntime, OpenAIAdapter } from "@copilotkit/runtime";
import OpenAI from "openai";
import { NextRequest } from "next/server";

const openai = new OpenAI({ 
  apiKey: process.env.OPENAI_API_KEY 
});

export async function POST(req: NextRequest) {
  const copilotKit = new CopilotRuntime();
  
  return copilotKit.response(
    req,
    new OpenAIAdapter({ 
      openai, 
      model: "gpt-4-turbo-preview" 
    })
  );
}

export const runtime = 'edge';
```

### Step 4: Implement Component Registry (Static Archetype)

Create `lib/registry/index.ts`:

```typescript
import { z } from "zod";

export interface ComponentMetadata {
  name: string;
  description: string;
  category: string;
  tags: string[];
  examples: string[];
}

export interface RegisteredComponent {
  component: React.ComponentType<any>;
  schema: z.ZodSchema;
  metadata: ComponentMetadata;
}

class ComponentRegistry {
  private components = new Map<string, RegisteredComponent>();

  register(name: string, registration: RegisteredComponent): void {
    this.components.set(name, registration);
  }

  get(name: string): RegisteredComponent | undefined {
    return this.components.get(name);
  }

  list(): string[] {
    return Array.from(this.components.keys());
  }

  search(query: string): RegisteredComponent[] {
    const results: RegisteredComponent[] = [];
    
    for (const [name, comp] of this.components) {
      const searchableText = `
        ${name} 
        ${comp.metadata.description} 
        ${comp.metadata.tags.join(' ')}
      `.toLowerCase();
      
      if (searchableText.includes(query.toLowerCase())) {
        results.push(comp);
      }
    }
    
    return results;
  }

  validate(name: string, props: any): { success: boolean; errors?: any } {
    const component = this.get(name);
    
    if (!component) {
      return { success: false, errors: "Component not found" };
    }
    
    const result = component.schema.safeParse(props);
    
    return {
      success: result.success,
      errors: result.success ? undefined : result.error
    };
  }

  toJSON() {
    return Array.from(this.components.entries()).map(([name, comp]) => ({
      name,
      metadata: comp.metadata,
      schema: comp.schema.describe()
    }));
  }
}

export const componentRegistry = new ComponentRegistry();
```

Register sample components in `lib/registry/components/index.ts`:

```typescript
import { z } from "zod";
import { Button, Card, TextField } from "@mui/material";
import { componentRegistry } from "../index";

// Register Button component
componentRegistry.register("Button", {
  component: Button,
  schema: z.object({
    children: z.string(),
    variant: z.enum(["text", "outlined", "contained"]).optional(),
    color: z.enum(["primary", "secondary", "error", "warning"]).optional(),
    size: z.enum(["small", "medium", "large"]).optional(),
    disabled: z.boolean().optional(),
  }),
  metadata: {
    name: "Button",
    description: "Material-UI Button component for user actions",
    category: "Input",
    tags: ["button", "action", "click", "form"],
    examples: [
      '<Button variant="contained" color="primary">Click Me</Button>',
      '<Button variant="outlined">Cancel</Button>'
    ]
  }
});

// Register Card component
componentRegistry.register("Card", {
  component: Card,
  schema: z.object({
    children: z.any(),
    elevation: z.number().min(0).max(24).optional(),
    variant: z.enum(["elevation", "outlined"]).optional(),
  }),
  metadata: {
    name: "Card",
    description: "Container component for grouping content",
    category: "Layout",
    tags: ["card", "container", "surface"],
    examples: [
      '<Card elevation={3}><CardContent>Content here</CardContent></Card>'
    ]
  }
});

// Register TextField component
componentRegistry.register("TextField", {
  component: TextField,
  schema: z.object({
    label: z.string().optional(),
    placeholder: z.string().optional(),
    variant: z.enum(["outlined", "filled", "standard"]).optional(),
    type: z.enum(["text", "password", "email", "number"]).optional(),
    fullWidth: z.boolean().optional(),
    required: z.boolean().optional(),
  }),
  metadata: {
    name: "TextField",
    description: "Input field for text entry",
    category: "Input",
    tags: ["input", "textfield", "form", "text"],
    examples: [
      '<TextField label="Email" type="email" fullWidth />',
      '<TextField label="Password" type="password" />'
    ]
  }
});
```

### Step 5: Implement Schema Validator (Declarative Archetype)

Create `lib/schema/types.ts`:

```typescript
export interface UISchema {
  type: 'component' | 'container' | 'layout';
  component?: string;
  props?: Record<string, any>;
  children?: UISchema[];
  layout?: 'vertical' | 'horizontal' | 'grid';
  gridConfig?: {
    columns?: number;
    gap?: number;
  };
}

export interface ValidationResult {
  valid: boolean;
  errors?: string[];
}
```

Create `lib/schema/validator.ts`:

```typescript
import Ajv from "ajv";
import type { UISchema, ValidationResult } from "./types";

const ajv = new Ajv();

const uiSchemaJSONSchema = {
  type: "object",
  properties: {
    type: { type: "string", enum: ["component", "container", "layout"] },
    component: { type: "string" },
    props: { type: "object" },
    children: {
      type: "array",
      items: { $ref: "#" }
    },
    layout: { type: "string", enum: ["vertical", "horizontal", "grid"] },
    gridConfig: {
      type: "object",
      properties: {
        columns: { type: "number" },
        gap: { type: "number" }
      }
    }
  },
  required: ["type"]
};

export class SchemaValidator {
  private validate = ajv.compile(uiSchemaJSONSchema);

  validateSchema(schema: UISchema): ValidationResult {
    const valid = this.validate(schema);
    
    if (!valid) {
      return {
        valid: false,
        errors: this.validate.errors?.map(err => err.message) || []
      };
    }

    // Additional validation: check if components exist in registry
    if (schema.type === 'component' && schema.component) {
      const { componentRegistry } = require('../registry');
      if (!componentRegistry.get(schema.component)) {
        return {
          valid: false,
          errors: [`Component "${schema.component}" not found in registry`]
        };
      }
    }

    // Recursively validate children
    if (schema.children) {
      for (const child of schema.children) {
        const childValidation = this.validateSchema(child);
        if (!childValidation.valid) {
          return childValidation;
        }
      }
    }

    return { valid: true };
  }
}

export const schemaValidator = new SchemaValidator();
```

Create `lib/schema/transformer.tsx`:

```typescript
import React from "react";
import { Box, Stack, Grid } from "@mui/material";
import type { UISchema } from "./types";
import { componentRegistry } from "../registry";

export class SchemaTransformer {
  transform(schema: UISchema): React.ReactElement {
    switch (schema.type) {
      case 'component':
        return this.renderComponent(schema);
      case 'container':
        return this.renderContainer(schema);
      case 'layout':
        return this.renderLayout(schema);
      default:
        throw new Error(`Unknown schema type: ${schema.type}`);
    }
  }

  private renderComponent(schema: UISchema): React.ReactElement {
    if (!schema.component) {
      throw new Error("Component name is required");
    }

    const registered = componentRegistry.get(schema.component);
    
    if (!registered) {
      throw new Error(`Component "${schema.component}" not found`);
    }

    const Component = registered.component;
    const props = schema.props || {};

    // Render children recursively
    const children = schema.children?.map((child, idx) => 
      <React.Fragment key={idx}>{this.transform(child)}</React.Fragment>
    );

    return <Component {...props}>{children}</Component>;
  }

  private renderContainer(schema: UISchema): React.ReactElement {
    const children = schema.children?.map((child, idx) => 
      <React.Fragment key={idx}>{this.transform(child)}</React.Fragment>
    );

    return <Box {...(schema.props || {})}>{children}</Box>;
  }

  private renderLayout(schema: UISchema): React.ReactElement {
    const children = schema.children?.map((child, idx) => 
      <React.Fragment key={idx}>{this.transform(child)}</React.Fragment>
    );

    switch (schema.layout) {
      case 'vertical':
        return (
          <Stack direction="column" spacing={2} {...(schema.props || {})}>
            {children}
          </Stack>
        );
      
      case 'horizontal':
        return (
          <Stack direction="row" spacing={2} {...(schema.props || {})}>
            {children}
          </Stack>
        );
      
      case 'grid':
        return (
          <Grid 
            container 
            spacing={schema.gridConfig?.gap || 2}
            columns={schema.gridConfig?.columns || 12}
            {...(schema.props || {})}
          >
            {children?.map((child, idx) => (
              <Grid item key={idx}>{child}</Grid>
            ))}
          </Grid>
        );
      
      default:
        return <Box {...(schema.props || {})}>{children}</Box>;
    }
  }
}

export const schemaTransformer = new SchemaTransformer();
```

### Step 6: Implement Sandbox Manager (Open-Ended Archetype)

Create `lib/sandbox/security.ts`:

```typescript
export interface SecurityPolicy {
  allowedAPIs: string[];
  maxExecutionTime: number;
  maxMemory: number;
  allowNetworkAccess: boolean;
}

export const defaultSecurityPolicy: SecurityPolicy = {
  allowedAPIs: ['React', 'MUI', 'console'],
  maxExecutionTime: 5000,
  maxMemory: 50 * 1024 * 1024, // 50MB
  allowNetworkAccess: false
};

export function validateCode(code: string): { safe: boolean; issues: string[] } {
  const issues: string[] = [];
  
  // Check for dangerous patterns
  const dangerousPatterns = [
    /eval\(/,
    /Function\(/,
    /document\.write/,
    /innerHTML\s*=/,
    /<script/i,
    /import\s+.*\s+from\s+['"](?!react|@mui)/
  ];

  for (const pattern of dangerousPatterns) {
    if (pattern.test(code)) {
      issues.push(`Code contains potentially dangerous pattern: ${pattern}`);
    }
  }

  return {
    safe: issues.length === 0,
    issues
  };
}
```

Create `lib/sandbox/manager.ts`:

```typescript
import React from "react";
import { validateCode, SecurityPolicy, defaultSecurityPolicy } from "./security";

export interface SandboxConfig {
  securityPolicy?: SecurityPolicy;
  timeout?: number;
}

export class SandboxManager {
  async execute(
    code: string, 
    config: SandboxConfig = {}
  ): Promise<React.ComponentType> {
    const policy = config.securityPolicy || defaultSecurityPolicy;
    
    // Validate security
    const securityCheck = validateCode(code);
    if (!securityCheck.safe) {
      throw new Error(`Security validation failed: ${securityCheck.issues.join(', ')}`);
    }

    // Create a sandboxed component
    try {
      // In a real implementation, this would use a Web Worker or iframe
      // For this example, we'll use a simplified approach
      const Component = this.createComponent(code);
      
      return Component;
    } catch (error) {
      throw new Error(`Failed to execute sandboxed code: ${error}`);
    }
  }

  private createComponent(code: string): React.ComponentType {
    // This is a simplified version
    // In production, use a proper sandbox like iframe or Web Worker
    
    // Wrap the code in a React component
    const wrappedCode = `
      return function SandboxedComponent(props) {
        ${code}
      }
    `;
    
    try {
      // Create function with limited scope
      const createComponent = new Function('React', wrappedCode);
      return createComponent(React);
    } catch (error) {
      throw new Error(`Component creation failed: ${error}`);
    }
  }

  terminate(componentId: string): void {
    // Cleanup resources
    console.log(`Terminating sandbox: ${componentId}`);
  }
}

export const sandboxManager = new SandboxManager();
```

### Step 7: Create UI Components

Create `components/genui/SchemaRenderer.tsx`:

```tsx
'use client';

import React from "react";
import { schemaValidator } from "@/lib/schema/validator";
import { schemaTransformer } from "@/lib/schema/transformer";
import type { UISchema } from "@/lib/schema/types";
import { Alert } from "@mui/material";

interface SchemaRendererProps {
  schema: UISchema;
}

export function SchemaRenderer({ schema }: SchemaRendererProps) {
  const validation = schemaValidator.validateSchema(schema);

  if (!validation.valid) {
    return (
      <Alert severity="error">
        Schema validation failed: {validation.errors?.join(', ')}
      </Alert>
    );
  }

  try {
    return schemaTransformer.transform(schema);
  } catch (error) {
    return (
      <Alert severity="error">
        Rendering failed: {error instanceof Error ? error.message : 'Unknown error'}
      </Alert>
    );
  }
}
```

Create `components/genui/GenUIBuilder.tsx`:

```tsx
'use client';

import React, { useState } from "react";
import { useCopilotAction, useCopilotReadable } from "@copilotkit/react-core";
import { Box, Card, CardContent, Typography, Tabs, Tab } from "@mui/material";
import { componentRegistry } from "@/lib/registry";
import { SchemaRenderer } from "./SchemaRenderer";
import type { UISchema } from "@/lib/schema/types";

export function GenUIBuilder() {
  const [currentSchema, setCurrentSchema] = useState<UISchema | null>(null);
  const [activeTab, setActiveTab] = useState(0);

  // Make registry readable to AI
  useCopilotReadable({
    description: "Available UI components in the registry",
    value: componentRegistry.toJSON()
  });

  // Action to generate UI from description
  useCopilotAction({
    name: "generateUI",
    description: "Generate a UI layout from a natural language description",
    parameters: [
      {
        name: "description",
        type: "string",
        description: "Description of the UI to generate"
      }
    ],
    handler: async ({ description }) => {
      // This would typically call an AI service
      // For now, return a simple schema
      const schema: UISchema = {
        type: "layout",
        layout: "vertical",
        children: [
          {
            type: "component",
            component: "Card",
            children: [
              {
                type: "component",
                component: "TextField",
                props: { label: "Generated from: " + description }
              }
            ]
          }
        ]
      };

      setCurrentSchema(schema);
      return { success: true, schema };
    }
  });

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" gutterBottom>
        Generative UI Builder
      </Typography>

      <Tabs value={activeTab} onChange={(_, v) => setActiveTab(v)}>
        <Tab label="Builder" />
        <Tab label="Preview" />
        <Tab label="Code" />
      </Tabs>

      <Box sx={{ mt: 3 }}>
        {activeTab === 0 && (
          <Card>
            <CardContent>
              <Typography>
                Use the chat to generate UI components
              </Typography>
            </CardContent>
          </Card>
        )}

        {activeTab === 1 && currentSchema && (
          <Card>
            <CardContent>
              <SchemaRenderer schema={currentSchema} />
            </CardContent>
          </Card>
        )}

        {activeTab === 2 && (
          <Card>
            <CardContent>
              <pre>{JSON.stringify(currentSchema, null, 2)}</pre>
            </CardContent>
          </Card>
        )}
      </Box>
    </Box>
  );
}
```

### Step 8: Create GenUI Page

Create `app/genui/page.tsx`:

```tsx
import { GenUIBuilder } from "@/components/genui/GenUIBuilder";
import { CopilotPopup } from "@copilotkit/react-ui";
import "@copilotkit/react-ui/styles.css";

export default function GenUIPage() {
  return (
    <>
      <GenUIBuilder />
      <CopilotPopup
        instructions="You are a UI generation assistant. Help users create beautiful UIs using the available component registry."
        defaultOpen={true}
      />
    </>
  );
}
```

## Testing

### Unit Tests

Create `__tests__/registry.test.ts`:

```typescript
import { componentRegistry } from "@/lib/registry";

describe("ComponentRegistry", () => {
  it("should register and retrieve components", () => {
    const component = componentRegistry.get("Button");
    expect(component).toBeDefined();
    expect(component?.metadata.name).toBe("Button");
  });

  it("should validate props", () => {
    const result = componentRegistry.validate("Button", {
      children: "Click me",
      variant: "contained"
    });
    expect(result.success).toBe(true);
  });

  it("should fail validation for invalid props", () => {
    const result = componentRegistry.validate("Button", {
      variant: "invalid"
    });
    expect(result.success).toBe(false);
  });
});
```

## Deployment

### Environment Setup

Create `.env.local`:

```env
OPENAI_API_KEY=your_openai_api_key
NEXT_PUBLIC_COPILOT_RUNTIME_URL=/api/copilotkit
```

### Build and Deploy

```bash
# Build the application
pnpm build

# Start production server
pnpm start

# Or deploy to Vercel
vercel deploy
```

## Performance Optimization

### Code Splitting

Use dynamic imports for heavy components:

```tsx
const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <CircularProgress />
});
```

### Memoization

Memoize expensive computations:

```tsx
const transformedSchema = useMemo(
  () => schemaTransformer.transform(schema),
  [schema]
);
```

### Caching

Implement caching for AI responses:

```typescript
const cache = new Map<string, any>();

export async function cachedGeneration(prompt: string) {
  if (cache.has(prompt)) {
    return cache.get(prompt);
  }
  
  const result = await generateWithAI(prompt);
  cache.set(prompt, result);
  return result;
}
```

## Security Best Practices

1. **Input Validation**: Always validate user inputs and AI-generated schemas
2. **CSP Headers**: Implement strict Content Security Policy
3. **Rate Limiting**: Limit AI API calls to prevent abuse
4. **Sandboxing**: Execute untrusted code in isolated environments
5. **Authentication**: Protect GenUI endpoints with proper authentication

## Monitoring and Analytics

Track key metrics:

```typescript
export function trackGenUIMetrics(event: string, data: any) {
  // Send to analytics service
  console.log('GenUI Metric:', event, data);
}

// Usage
trackGenUIMetrics('component_generated', {
  archetype: 'declarative',
  componentCount: 5,
  generationTime: 1234
});
```

## Troubleshooting

### Common Issues

**Issue**: CopilotKit not connecting
- **Solution**: Verify `OPENAI_API_KEY` is set and `/api/copilotkit` route is working

**Issue**: Component not rendering
- **Solution**: Check component is registered in registry and props are valid

**Issue**: Sandbox execution fails
- **Solution**: Review security policy and code validation errors

## Next Steps

1. Extend component registry with custom components
2. Implement advanced schema features (conditional rendering, data binding)
3. Enhance sandbox security with Web Workers
4. Add real-time collaboration features
5. Integrate with backend APIs for data-driven UIs

## Conclusion

This implementation provides a solid foundation for building generative UI experiences. Start with the Static archetype for predictable components, move to Declarative for flexibility, and use Open-Ended for maximum creativity. Always prioritize security, performance, and user experience.
